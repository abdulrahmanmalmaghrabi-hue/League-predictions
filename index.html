<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <meta name="theme-color" content="#4CAF50" />
  <title>Premier League Predictions</title>
  <style>
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent }
    body { font-family: 'Segoe UI', Tahoma, sans-serif; background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%); padding: 10px; margin: 0; min-height: 100vh; color: #333; }
    h1 { color: white; text-align: center; font-size: 1.5rem; margin: 10px 0; text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
    .box { background: rgba(255,255,255,0.95); padding: 15px; border-radius: 15px; margin-bottom: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.2); backdrop-filter: blur(10px); }
    h2 { margin-top: 0; color: #2a5298; font-size: 1.2rem; border-bottom: 2px solid #4CAF50; padding-bottom: 10px; }
    input, button, select { padding: 12px; margin: 8px 0; width: 100%; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; transition: all 0.3s ease; }
    input:focus, select:focus { outline: none; border-color: #4CAF50; box-shadow: 0 0 5px rgba(76,175,80,0.3); }
    button { cursor: pointer; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px; }
    button:active { transform: scale(0.98) }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn-primary { background: linear-gradient(135deg, #4CAF50, #45a049); color: white; border: none }
    .btn-danger { background: linear-gradient(135deg, #f44336, #d32f2f); color: white; border: none }
    .btn-warning { background: linear-gradient(135deg, #ff9800, #f57c00); color: white; border: none }
    .btn-info { background: linear-gradient(135deg, #2196F3, #1976D2); color: white; border: none }
    .match-row { display: flex; gap: 8px; margin: 8px 0; align-items: center; background: #f5f5f5; padding: 8px; border-radius: 8px; }
    .match-row input { width: 35%; text-align: center; font-weight: bold; }
    .match-row label { width: 30%; text-align: center; font-weight: bold; color: #2a5298; }
    .match-row.locked { background: #ffebee; opacity: 0.7; }
    .match-row.locked input { background: #ffcdd2; pointer-events: none; }
    .leaderboard { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 14px; }
    .leaderboard th, .leaderboard td { border: 1px solid #ddd; padding: 10px; text-align: center }
    .leaderboard th { background: linear-gradient(135deg, #4CAF50, #45a049); color: white; position: sticky; top: 0; }
    .leaderboard tr:nth-child(even) { background: #f9f9f9 } .leaderboard tr:hover { background: #e3f2fd }
    .rank-1 { background: gold !important; font-weight: bold } .rank-2 { background: silver !important; font-weight: bold } .rank-3 { background: #cd7f32 !important; font-weight: bold; color: white }
    #adminPanel { background: linear-gradient(135deg, #fff3e0, #ffe0b2); border: 2px solid #ff9800 }
    .admin-section { margin: 15px 0; padding: 15px; border: 1px solid #ddd; border-radius: 10px; background: white; }
    .hidden { display: none !important }
    #loading { text-align: center; padding: 40px; color: white; font-size: 1.2rem; }
    .spinner { border: 4px solid rgba(255,255,255,0.3); border-top: 4px solid white; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 20px auto; }
    @keyframes spin { 0% { transform: rotate(0deg) } 100% { transform: rotate(360deg) } }
    .badge { display: inline-block; padding: 4px 12px; border-radius: 20px; font-size: 12px; font-weight: bold; }
    .badge-admin { background: #ff9800; color: white } .badge-user { background: #4CAF50; color: white }
    .error-msg { color: #f44336; font-size: 14px; margin: 5px 0; display: none; }
    .success-msg { color: #4CAF50; font-size: 14px; margin: 5px 0; display: none; }
    .countdown { background: #ffeb3b; color: #333; padding: 10px; border-radius: 8px; text-align: center; font-weight: bold; margin: 10px 0; }
    .match-info { font-size: 12px; color: #666; margin-top: 4px; }
    .toast { position: fixed; bottom: 20px; right: 20px; background: #333; color: white; padding: 15px 20px; border-radius: 8px; z-index: 1000; animation: slideIn 0.3s ease; }
    @keyframes slideIn { from { transform: translateX(100%); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
    .toast.error { background: #f44336; }
    .toast.success { background: #4CAF50; }
    @media (max-width: 400px) { body { padding: 5px } .box { padding: 10px } h1 { font-size: 1.2rem } }
  </style>
</head>
<body>

<div id="loading">
  <div class="spinner"></div>
  <p>Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØªØ·Ø¨ÙŠÙ‚...</p>
</div>

<h1>âš½ Premier League Predictions</h1>

<div class="box hidden" id="loginPage">
  <h2>ğŸ” ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„</h2>
  <input id="email" placeholder="Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ" type="email" autocomplete="off">
  <input id="password" placeholder="ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±" type="password">
  <button class="btn-primary" id="loginBtn" onclick="login()">Ø¯Ø®ÙˆÙ„</button>
  <p id="userInfo"></p>
  <span id="adminBadge" class="badge badge-admin hidden">ğŸ‘‘ Ù…Ø´Ø±Ù</span>
</div>

<div id="adminPanel" class="box hidden">
  <div style="display:flex; justify-content:space-between; align-items:center">
    <h2>ğŸ‘‘ Ù„ÙˆØ­Ø© Ø§Ù„ØªØ­ÙƒÙ…</h2>
    <button class="btn-danger" onclick="logout()" style="width:auto; padding:8px 16px">Ø®Ø±ÙˆØ¬</button>
  </div>

  <div class="admin-section">
    <h3>âš½ Ø¥Ø¶Ø§ÙØ© Ù…Ø¨Ø§Ø±Ø§Ø©</h3>
    <input id="matchRound" placeholder="Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆÙ„Ø© (1-38)" type="number" min="1" max="38">
    <input id="matchName" placeholder="Ø§Ø³Ù… Ø§Ù„Ù…Ø¨Ø§Ø±Ø© (Ù…Ø«Ø§Ù„: Ù„ÙŠÙØ±Ø¨ÙˆÙ„ vs Ù…Ø§Ù†Ø´Ø³ØªØ± Ø³ÙŠØªÙŠ)">
    <input id="matchTime" type="datetime-local">
    <button class="btn-info" onclick="addMatch()">â• Ø¥Ø¶Ø§ÙØ©</button>
    <div id="matchesList" style="margin-top:10px; max-height:200px; overflow-y:auto"></div>
  </div>

  <div class="admin-section">
    <h3>ğŸ“ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¬ÙˆÙ„Ø§Øª</h3>
    <input id="adminRound" placeholder="Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆÙ„Ø©" type="number" min="1" max="38">
    <div id="adminMatchesContainer"></div>
    <button class="btn-warning" onclick="postResults()" id="postResultsBtn">Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ + Ù‚ÙÙ„ Ø§Ù„Ø¬ÙˆÙ„Ø©</button>
    <p class="error-msg" id="adminError"></p>
  </div>

  <div class="admin-section">
    <h3>ğŸ‘¥ Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†</h3>
    <input id="userEmail" placeholder="Ø¨Ø±ÙŠØ¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø¬Ø¯ÙŠØ¯">
    <input id="userPassword" placeholder="ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„Ù…Ø¤Ù‚ØªÙŠØ©" type="password">
    <select id="userRole">
      <option value="user">Ù…Ø³ØªØ®Ø¯Ù… Ø¹Ø§Ø¯ÙŠ</option>
      <option value="admin">Ù…Ø´Ø±Ù</option>
    </select>
    <div style="display:flex; gap:10px">
      <button class="btn-info" onclick="addUser()" style="flex:1">â• Ø¥Ø¶Ø§ÙØ©</button>
    </div>
    <div id="usersList" style="margin-top:10px; max-height:150px; overflow-y:auto"></div>
  </div>
</div>

<div id="userPanel" class="box hidden">
  <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px">
    <h2 style="margin:0">ğŸ‘¤ ØªÙˆÙ‚Ø¹Ø§ØªÙŠ</h2>
    <div>
      <span class="badge badge-user">Ù…Ø³ØªØ®Ø¯Ù…</span>
      <button class="btn-danger" onclick="logout()" style="width:auto; padding:6px 12px; font-size:12px">Ø®Ø±ÙˆØ¬</button>
    </div>
  </div>

  <div class="countdown hidden" id="countdown">
    â° Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…ØªØ¨Ù‚ÙŠ Ù„Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª: <span id="timeLeft">--:--:--</span>
  </div>

  <input id="roundNumber" placeholder="Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆÙ„Ø© (1-38)" type="number" min="1" max="38" onchange="loadRoundMatches()">

  <div style="margin:15px 0; padding:10px; background:#e3f2fd; border-radius:8px">
    <label><strong>ğŸ¯ Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø© Ø§Ù„Ù…Ø¶Ø§Ø¹ÙØ© (Ø§Ø®ØªÙŠØ§Ø±ÙŠ):</strong></label>
    <select id="doubleMatch"><option value="0">Ø¨Ø¯ÙˆÙ† Ù…Ø¶Ø§Ø¹ÙØ©</option></select>
    <small style="color:#666; display:block; margin-top:5px">Ø§Ø®ØªØ± Ù…Ø¨Ø§Ø±Ø§Ø© ÙˆØ§Ø­Ø¯Ø© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¶Ø¹Ù Ø§Ù„Ù†Ù‚Ø§Ø· (6 Ù†Ù‚Ø§Ø·)</small>
  </div>

  <div id="matchesContainer"></div>
  <p class="error-msg" id="predictionError"></p>
  <p class="success-msg" id="predictionSuccess"></p>
  <button class="btn-primary" onclick="submitUserPrediction()" id="submitBtn">ğŸ“¤ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙ‚Ø¹</button>
</div>

<div class="box">
  <h2>ğŸ† Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†</h2>
  <button class="btn-info" onclick="loadLeaderboard()" style="margin-bottom:10px">ğŸ”„ ØªØ­Ø¯ÙŠØ«</button>
  <div id="leaderboardContainer" style="max-height:400px; overflow-y:auto"></div>
</div>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import { getAuth, signInWithEmailAndPassword, onAuthStateChanged, signOut, setPersistence, browserLocalPersistence, createUserWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
  import { getFirestore, doc, setDoc, getDoc, updateDoc, deleteDoc, collection, addDoc, getDocs, query, orderBy, limit, serverTimestamp, enableIndexedDbPersistence } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAQw9E_LtJ5QQDGpkGV6n9-re3CD7DLvbk",
    authDomain: "englishleagueapp-6337c.firebaseapp.com",
    projectId: "englishleagueapp-6337c",
    storageBucket: "englishleagueapp-6337c.firebasestorage.app",
    messagingSenderId: "441958380116",
    appId: "1:441958380116:web:741712fe2ca9471e81f3c1",
    measurementId: "G-ETQNFJQBN2"
  };

  const app = initializeApp(firebaseConfig);
  const auth = getAuth(app);
  const db = getFirestore(app);

  // Helper functions
  const show = (id) => document.getElementById(id)?.classList.remove("hidden");
  const hide = (id) => document.getElementById(id)?.classList.add("hidden");
  const showToast = (msg, type = 'success') => {
    const toast = document.createElement('div');
    toast.className = `toast ${type}`;
    toast.textContent = msg;
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 3000);
  };

  let currentMatches = [];
  let countdownInterval;

  // Create match inputs dynamically
  function createMatchInputs(containerId, prefix, isAdmin = false) {
    const container = document.getElementById(containerId);
    if (!container) return;
    container.innerHTML = '';
    for (let i = 1; i <= 10; i++) {
      const div = document.createElement('div');
      div.className = 'match-row';
      div.id = `${prefix}row${i}`;
      div.innerHTML = `
        <label>Ù…${i}</label>
        <input id="${prefix}${i}h" placeholder="0" type="number" min="0" max="20" inputmode="numeric">
        <input id="${prefix}${i}a" placeholder="0" type="number" min="0" max="20" inputmode="numeric">
        <div class="match-info" id="${prefix}info${i}"></div>
      `;
      container.appendChild(div);
    }
  }

  createMatchInputs('matchesContainer', 'm');
  createMatchInputs('adminMatchesContainer', 'a', true);

  // Populate double match select
  const doubleSelect = document.getElementById('doubleMatch');
  for (let i = 1; i <= 10; i++) {
    const opt = document.createElement('option');
    opt.value = String(i);
    opt.textContent = `Ù…Ø¨Ø§Ø±Ø§Ø© ${i}`;
    doubleSelect.appendChild(opt);
  }

  // Auth state ready
  function authStateReady() {
    return new Promise(resolve => {
      const unsub = onAuthStateChanged(auth, user => {
        unsub();
        resolve(user);
      });
    });
  }

  async function checkIfAdmin(uid) {
    try {
      const snap = await getDoc(doc(db, "admins", uid));
      return snap.exists() && snap.data().role === "admin";
    } catch (e) {
      console.error("checkIfAdmin error:", e);
      return false;
    }
  }

  // Initialize app
  async function initApp() {
    try {
      try {
        await setPersistence(auth, browserLocalPersistence);
        await enableIndexedDbPersistence(db);
      } catch (e) {
        console.warn("Persistence not enabled:", e);
      }

      show("loading");
      hide("loginPage"); hide("adminPanel"); hide("userPanel");

      const user = await authStateReady();
      let isAdmin = false;
      if (user) {
        isAdmin = await checkIfAdmin(user.uid);
      }

      hide("loading");

      if (isAdmin) {
        show("adminPanel");
        document.getElementById("adminBadge")?.classList.remove("hidden");
        await loadMatches(); 
        await loadUsers();
      } else if (user) {
        show("userPanel");
        document.getElementById("adminBadge")?.classList.add("hidden");
      } else {
        show("loginPage");
        document.getElementById("userInfo").innerText = "ØºÙŠØ± Ù…Ø³Ø¬Ù„";
      }

      await loadLeaderboard();
    } catch (err) {
      console.error("initApp error:", err);
      hide("loading");
      showToast("Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚", "error");
    }
  }

  // Auth functions
  window.login = async () => {
    const btn = document.getElementById('loginBtn');
    btn.disabled = true;
    btn.innerHTML = '<div class="spinner" style="width:20px;height:20px;display:inline-block;border-width:2px"></div>';
    
    try {
      const email = document.getElementById('email').value.trim();
      const password = document.getElementById('password').value;
      
      if (!email || !password) {
        throw new Error('Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±');
      }
      
      await signInWithEmailAndPassword(auth, email, password);
      await initApp();
      showToast('ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¨Ù†Ø¬Ø§Ø­');
    } catch (e) {
      console.error("login error:", e);
      let msg = 'Ø®Ø·Ø£ ÙÙŠ ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„';
      if (e.code === 'auth/user-not-found') msg = 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯';
      else if (e.code === 'auth/wrong-password') msg = 'ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø®Ø§Ø·Ø¦Ø©';
      else if (e.code === 'auth/invalid-email') msg = 'Ø¨Ø±ÙŠØ¯ Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ ØºÙŠØ± ØµØ§Ù„Ø­';
      else if (e.message) msg = e.message;
      
      showToast(msg, 'error');
    } finally {
      btn.disabled = false;
      btn.textContent = 'Ø¯Ø®ÙˆÙ„';
    }
  };

  window.logout = async () => { 
    await signOut(auth); 
    location.reload(); 
  };

  // Admin functions
  window.addMatch = async () => {
    try {
      const round = document.getElementById('matchRound').value;
      const name = document.getElementById('matchName').value.trim();
      const time = document.getElementById('matchTime').value;
      
      if (!round || !name) return showToast('Ø£ÙƒÙ…Ù„ Ø§Ù„Ø­Ù‚ÙˆÙ„ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©', 'error');
      if (round < 1 || round > 38) return showToast('Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆÙ„Ø© ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨ÙŠÙ† 1 Ùˆ 38', 'error');
      
      await addDoc(collection(db, "matches"), { 
        round: parseInt(round), 
        name, 
        time, 
        created_at: serverTimestamp(),
        status: 'upcoming'
      });
      
      showToast("âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø¨Ø§Ø±Ø§Ø©");
      await loadMatches();
      
      // Clear inputs
      document.getElementById('matchName').value = '';
      document.getElementById('matchTime').value = '';
    } catch (e) { 
      console.error(e); 
      showToast('Ø®Ø·Ø£: ' + e.message, 'error'); 
    }
  };

  window.addUser = async () => {
    try {
      const email = document.getElementById('userEmail').value.trim();
      const password = document.getElementById('userPassword').value;
      const role = document.getElementById('userRole').value;
      
      if (!email || !password) return showToast('Ø£Ø¯Ø®Ù„ Ø§Ù„Ø¨Ø±ÙŠØ¯ ÙˆÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±', 'error');
      if (password.length < 6) return showToast('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ÙŠØ¬Ø¨ Ø£Ù† ØªÙƒÙˆÙ† 6 Ø£Ø­Ø±Ù Ø¹Ù„Ù‰ Ø§Ù„Ø£Ù‚Ù„', 'error');
      
      // Create user in Auth
      const userCred = await createUserWithEmailAndPassword(auth, email, password);
      
      // Add to admins collection for role management
      await setDoc(doc(db, "admins", userCred.user.uid), { 
        email, 
        role,
        created_at: serverTimestamp()
      });
      
      showToast("âœ… ØªÙ… Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…");
      await loadUsers();
      
      // Clear inputs
      document.getElementById('userEmail').value = '';
      document.getElementById('userPassword').value = '';
    } catch (e) { 
      console.error(e);
      let msg = e.message;
      if (e.code === 'auth/email-already-in-use') msg = 'Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„ÙØ¹Ù„';
      showToast('Ø®Ø·Ø£: ' + msg, 'error'); 
    }
  };

  // Loaders
  async function loadMatches() {
    try {
      const q = query(collection(db, "matches"), orderBy("created_at", "desc"), limit(50));
      const snap = await getDocs(q);
      let html = '';
      snap.forEach(d => { 
        const o = d.data(); 
        const time = o.time ? new Date(o.time).toLocaleString('ar-SA') : 'ØºÙŠØ± Ù…Ø­Ø¯Ø¯';
        html += `<div style="padding:8px; border-bottom:1px solid #eee">
          <strong>${o.name}</strong> - Ø¬ÙˆÙ„Ø© ${o.round}<br>
          <small style="color:#666">${time}</small>
        </div>`; 
      });
      document.getElementById("matchesList").innerHTML = html || 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø¨Ø§Ø±ÙŠØ§Øª';
    } catch (e) { 
      console.error('loadMatches', e); 
    }
  }

  async function loadUsers() {
    try {
      const snap = await getDocs(collection(db, "admins"));
      let html = '';
      snap.forEach(d => { 
        const o = d.data(); 
        const roleBadge = o.role === 'admin' ? 'ğŸ‘‘ Ù…Ø´Ø±Ù' : 'ğŸ‘¤ Ù…Ø³ØªØ®Ø¯Ù…';
        html += `<div style="padding:8px; border-bottom:1px solid #eee">
          ${o.email} <span class="badge" style="background:${o.role === 'admin' ? '#ff9800' : '#4CAF50'}; color:white">${roleBadge}</span>
        </div>`; 
      });
      document.getElementById("usersList").innerHTML = html || 'Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†';
    } catch (e) { 
      console.error('loadUsers', e); 
    }
  }

  // Post results with security
  window.postResults = async () => {
    const btn = document.getElementById('postResultsBtn');
    btn.disabled = true;
    
    try {
      const roundNum = document.getElementById('adminRound').value;
      if (!roundNum) return showToast('Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø§Ù„Ø¬ÙˆÙ„Ø©', 'error');
      
      const round = "round_" + roundNum;
      const actualResult = {
        round: parseInt(roundNum),
        posted_at: serverTimestamp(),
        posted_by: auth.currentUser.uid
      };
      
      // Collect results
      for (let i = 1; i <= 10; i++) {
        const home = document.getElementById(`a${i}h`).value;
        const away = document.getElementById(`a${i}a`).value;
        
        if (home === '' || away === '') {
          return showToast(`Ø£ÙƒÙ…Ù„ Ù†ØªÙŠØ¬Ø© Ù…Ø¨Ø§Ø±Ø§Ø© ${i}`, 'error');
        }
        
        actualResult[`match_${i}_home`] = parseInt(home);
        actualResult[`match_${i}_away`] = parseInt(away);
      }
      
      // Save results
      await setDoc(doc(db, "actual_results", round), actualResult);
      
      // Lock round
      await setDoc(doc(db, "rounds", round), { 
        is_locked: true, 
        locked_at: serverTimestamp(),
        locked_by: auth.currentUser.uid
      });
      
      // Calculate points locally then update (batch)
      await calculateAndUpdatePoints(round, actualResult);
      
      showToast("ğŸ† ØªÙ… Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬ ÙˆØ­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø·!");
      await loadLeaderboard();
      
    } catch (e) { 
      console.error('postResults', e); 
      showToast('Ø®Ø·Ø£: ' + e.message, 'error'); 
    } finally {
      btn.disabled = false;
    }
  };

  async function calculateAndUpdatePoints(round, actualResult) {
    try {
      const predsSnap = await getDocs(collection(db, "predictions", round, "users"));
      
      // Process in batches of 500 (Firestore limit)
      let batch = writeBatch(db);
      let count = 0;
      const batches = [];
      
      predsSnap.forEach(p => {
        const d = p.data();
        let pts = 0;
        
        for (let i = 1; i <= 10; i++) {
          const userHome = d[`match_${i}_home`];
          const userAway = d[`match_${i}_away`];
          const actualHome = actualResult[`match_${i}_home`];
          const actualAway = actualResult[`match_${i}_away`];
          
          if (userHome === actualHome && userAway === actualAway) {
            pts += 3;
            if (d.double_match === i) pts += 3;
          }
        }
        
        // Update prediction doc
        batch.update(p.ref, { 
          total_points: pts, 
          calculated_at: serverTimestamp() 
        });
        
        // Update leaderboard
        const leaderboardRef = doc(db, "leaderboard", p.id);
        batch.set(leaderboardRef, { 
          participant_name: d.participant_name || d.email || 'Ù…Ø¬Ù‡ÙˆÙ„',
          total_points: pts,
          updated_at: serverTimestamp()
        }, { merge: true });
        
        count++;
        if (count === 500) {
          batches.push(batch.commit());
          batch = writeBatch(db);
          count = 0;
        }
      });
      
      if (count > 0) {
        batches.push(batch.commit());
      }
      
      await Promise.all(batches);
      
    } catch (e) {
      console.error('calculatePoints error:', e);
      throw e;
    }
  }

  // User prediction with validation
  window.submitUserPrediction = async () => {
    const btn = document.getElementById('submitBtn');
    const errorEl = document.getElementById('predictionError');
    const successEl = document.getElementById('predictionSuccess');
    
    btn.disabled = true;
    errorEl.style.display = 'none';
    successEl.style.display = 'none';
    
    try {
      const user = auth.currentUser;
      if (!user) return showToast('Ø³Ø¬Ù‘Ù„ Ø¯Ø®ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹', 'error');
      
      const roundNum = document.getElementById('roundNumber').value;
      if (!roundNum || roundNum < 1 || roundNum > 38) {
        throw new Error('Ø£Ø¯Ø®Ù„ Ø±Ù‚Ù… Ø¬ÙˆÙ„Ø© ØµØ­ÙŠØ­ (1-38)');
      }
      
      const round = "round_" + roundNum;
      
      // Check if locked
      const roundSnap = await getDoc(doc(db, "rounds", round));
      if (roundSnap.exists() && roundSnap.data().is_locked) {
        throw new Error('âŒ Ø§Ù„Ø¬ÙˆÙ„Ø© Ù…Ù‚ÙÙ„Ø©! Ù„Ø§ ÙŠÙ…ÙƒÙ† Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª');
      }
      
      // Check deadline from matches
      const matchesQuery = query(
        collection(db, "matches"), 
        where("round", "==", parseInt(roundNum)),
        orderBy("time"),
        limit(1)
      );
      const matchesSnap = await getDocs(matchesQuery);
      
      if (!matchesSnap.empty) {
        const firstMatch = matchesSnap.docs[0].data();
        if (firstMatch.time) {
          const matchTime = new Date(firstMatch.time);
          const now = new Date();
          const timeDiff = matchTime - now;
          
          if (timeDiff < 0) {
            throw new Error('âŒ Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙ‚Ø¹Ø§Øª (Ø¨Ø¯Ø£Øª Ø£ÙˆÙ„ Ù…Ø¨Ø§Ø±Ø§Ø©)');
          }
        }
      }
      
      // Validate all matches filled
      const prediction = {
        participant_name: user.email || user.uid,
        email: user.email,
        user_id: user.uid,
        round: parseInt(roundNum),
        double_match: parseInt(document.getElementById('doubleMatch').value) || 0,
        timestamp: serverTimestamp(),
        total_points: 0
      };
      
      for (let i = 1; i <= 10; i++) {
        const home = document.getElementById(`m${i}h`).value;
        const away = document.getElementById(`m${i}a`).value;
        
        if (home === '' || away === '') {
          throw new Error(`Ø£ÙƒÙ…Ù„ ØªÙˆÙ‚Ø¹ Ù…Ø¨Ø§Ø±Ø§Ø© ${i}`);
        }
        
        const homeVal = parseInt(home);
        const awayVal = parseInt(away);
        
        if (homeVal < 0 || homeVal > 20 || awayVal < 0 || awayVal > 20) {
          throw new Error(`ØªÙˆÙ‚Ø¹ Ù…Ø¨Ø§Ø±Ø§Ø© ${i} ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ø¨ÙŠÙ† 0 Ùˆ 20`);
        }
        
        prediction[`match_${i}_home`] = homeVal;
        prediction[`match_${i}_away`] = awayVal;
      }
      
      // Check if already submitted (update instead of create)
      const existingPred = await getDoc(doc(db, "predictions", round, "users", user.uid));
      if (existingPred.exists()) {
        await updateDoc(doc(db, "predictions", round, "users", user.uid), prediction);
        showToast("âœ… ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„ØªÙˆÙ‚Ø¹");
      } else {
        await setDoc(doc(db, "predictions", round, "users", user.uid), prediction);
        showToast("âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØªÙˆÙ‚Ø¹ Ø¨Ù†Ø¬Ø§Ø­");
      }
      
      successEl.textContent = 'ØªÙ… Ø§Ù„Ø­ÙØ¸ Ø¨Ù†Ø¬Ø§Ø­!';
      successEl.style.display = 'block';
      
    } catch (e) { 
      console.error('submitUserPrediction', e);
      errorEl.textContent = e.message;
      errorEl.style.display = 'block';
      showToast(e.message, 'error');
    } finally {
      btn.disabled = false;
    }
  };

  // Load matches for specific round
  window.loadRoundMatches = async () => {
    const roundNum = document.getElementById('roundNumber').value;
    if (!roundNum) return;
    
    try {
      const q = query(
        collection(db, "matches"), 
        where("round", "==", parseInt(roundNum)),
        orderBy("time")
      );
      const snap = await getDocs(q);
      
      currentMatches = [];
      snap.forEach((d, idx) => {
        if (idx < 10) {
          currentMatches.push({ id: d.id, ...d.data() });
        }
      });
      
      // Update UI with match names
      currentMatches.forEach((match, idx) => {
        const i = idx + 1;
        const infoEl = document.getElementById(`minfo${i}`);
        if (infoEl && match.name) {
          infoEl.textContent = match.name;
        }
        
        // Update double match select
        const opt = doubleSelect.options[i];
        if (opt && match.name) {
          opt.textContent = `${i} - ${match.name}`;
        }
      });
      
      // Start countdown if matches found
      if (currentMatches.length > 0 && currentMatches[0].time) {
        startCountdown(currentMatches[0].time);
      }
      
    } catch (e) {
      console.error('loadRoundMatches', e);
    }
  };

  function startCountdown(matchTime) {
    clearInterval(countdownInterval);
    show('countdown');
    
    const updateCountdown = () => {
      const now = new Date();
      const match = new Date(matchTime);
      const diff = match - now;
      
      if (diff <= 0) {
        document.getElementById('timeLeft').textContent = '00:00:00';
        document.getElementById('submitBtn').disabled = true;
        document.getElementById('submitBtn').textContent = 'â›” Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ù„ØªÙˆÙ‚Ø¹';
        return;
      }
      
      const hours = Math.floor(diff / (1000 * 60 * 60));
      const minutes = Math.floor((diff % (1000 * 60 * 60)) / (1000 * 60));
      const seconds = Math.floor((diff % (1000 * 60)) / 1000);
      
      document.getElementById('timeLeft').textContent = 
        `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    };
    
    updateCountdown();
    countdownInterval = setInterval(updateCountdown, 1000);
  }

  // Leaderboard
  async function loadLeaderboard() {
    try {
      const q = query(collection(db, "leaderboard"), orderBy("total_points", "desc"), limit(20));
      const snap = await getDocs(q);
      
      let html = `<table class="leaderboard"><tr><th>Ø§Ù„Ù…Ø±ÙƒØ²</th><th>Ø§Ù„Ù„Ø§Ø¹Ø¨</th><th>Ø§Ù„Ù†Ù‚Ø§Ø·</th></tr>`;
      let rank = 1;
      
      snap.forEach(s => {
        const d = s.data();
        const rankClass = rank <= 3 ? `rank-${rank}` : '';
        const medal = rank === 1 ? 'ğŸ¥‡' : rank === 2 ? 'ğŸ¥ˆ' : rank === 3 ? 'ğŸ¥‰' : rank;
        html += `<tr class="${rankClass}">
          <td>${medal}</td>
          <td>${d.participant_name || 'Ù…Ø¬Ù‡ÙˆÙ„'}</td>
          <td><strong>${d.total_points || 0}</strong></td>
        </tr>`;
        rank++;
      });
      
      html += '</table>';
      document.getElementById("leaderboardContainer").innerHTML = html || '<p style="text-align:center">Ù„Ø§ ØªÙˆØ¬Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª</p>';
    } catch (e) { 
      console.error('loadLeaderboard', e); 
      document.getElementById("leaderboardContainer").innerText = 'Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…ØªØµØ¯Ø±ÙŠÙ†';
    }
  }

  // Cleanup on unload
  window.addEventListener('beforeunload', () => {
    clearInterval(countdownInterval);
  });

  // Start
  document.addEventListener("DOMContentLoaded", initApp);
</script>

</body>
</html>